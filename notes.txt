Ben Awad's useState tutorial
https://www.youtube.com/watch?v=9xhKH43llhU

I didn't really know about computed property names, but when creating
an object you can use brackets around an expression to calculate a name for the
given property. This can be very useful for dynamically assigning properties in
a reducer or something like that, without having to write multiple object
templates or whatever

(something, label) => {
  objectToUpdate = {
    ...objectToUpdate,
    [label]: something
  }
}

which is cool in itself. What I had never considered though was deriving the
property name from the type or other html attribute of a given event or element.
For example, the above video has name attributes set on two different fields,
then  uses event.target.name as the property key to update the combined state
object. That's really elegant! I'm not sure if it's entirely defensible across a
whole codebase, off the top of my head
  - This requires referring back to the component template to determine the key
  that will be used for the update. This feels like unnecessary mental overhead.

but it's neat! I expect he'll have more and similar tricks to make note of in
the rest of the series.

Ben Awad's useEffect tutorial
https://youtu.be/j1ZRyw7OtZs

conceptually, the useEffect hook runs the given function whenever the component
renders. Remember that rending a functional component (usually) means running
the function, so it makes sense conceptually as a "do this whenever the
component renders" label.

useEffect has 2 arguments
  - the function that we want to run conditionally
  - an array of variables, updates to which will cause the hook to rerun 
    - [ideally?] this is a dependency array, and contains all the values that
    the effect depends on

the layout looks good, but I need to start writing multiple breakpoint for
screen sizes. It looks too big on wide screen. After that I can start working on
a comment chain.